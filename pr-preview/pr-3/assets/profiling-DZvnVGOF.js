import{f as n,j as e}from"./index-xNsX7Ar1.js";const l={description:"Profiling and debugging memory usage in Reth.",title:"Profiling reth"};function r(s){const i={a:"a",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...n(),...s.components};return e.jsxs(e.Fragment,{children:[e.jsx(i.header,{children:e.jsxs(i.h1,{id:"profiling-reth",children:["Profiling reth",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#profiling-reth",children:e.jsx(i.div,{"data-autolink-icon":!0})})]})}),`
`,e.jsxs(i.h4,{id:"table-of-contents",children:["Table of Contents",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#table-of-contents",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsxs(i.li,{children:[e.jsx(i.a,{href:"#memory-profiling",children:"Memory profiling"}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsx(i.li,{children:e.jsx(i.a,{href:"#jemalloc",children:"Jemalloc"})}),`
`,e.jsx(i.li,{children:e.jsx(i.a,{href:"#monitoring-memory-usage",children:"Monitoring memory usage"})}),`
`,e.jsx(i.li,{children:e.jsx(i.a,{href:"#limiting-process-memory",children:"Limiting process memory"})}),`
`,e.jsx(i.li,{children:e.jsx(i.a,{href:"#understanding-allocation-with-jeprof",children:"Understanding allocation with jeprof"})}),`
`]}),`
`]}),`
`]}),`
`,e.jsxs(i.h2,{id:"memory-profiling",children:["Memory profiling",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#memory-profiling",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:[`When a program consumes all of the system's available memory (and swap, if any), the OOM killer starts killing processes that are taking up the most memory, until the system has
memory available again. `,e.jsx(i.a,{href:"https://www.kernel.org/doc/gorman/html/understand/understand016.html",children:"See kernel.org for a great (although outdated) introduction to out-of-memory management."}),`.
Reth distributes to many different hardware targets, some with less memory than others. As a result, sometimes bugs can cause memory leaks or out-of-memory crashes for `,e.jsx(i.em,{children:"some"}),` users, but not others.
Reth is also a complex program, with many moving pieces, and it can be difficult to know where to start when debugging an OOM or other memory leak.
Understanding how to profile memory usage is an extremely valuable skill when faced with this type of problem, and can quickly help shed light on the root cause of a memory leak.`]}),`
`,e.jsx(i.p,{children:"In this tutorial, we will be reviewing:"}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsx(i.li,{children:"How to monitor reth's memory usage,"}),`
`,e.jsx(i.li,{children:"How to emulate a low-memory environment to lab-reproduce OOM crashes,"}),`
`,e.jsxs(i.li,{children:["How to enable ",e.jsx(i.code,{children:"jemalloc"})," and its built-in memory profiling, and"]}),`
`,e.jsxs(i.li,{children:["How to use ",e.jsx(i.code,{children:"jeprof"})," to interpret heap profiles and identify potential root causes for a memory leak."]}),`
`]}),`
`,e.jsxs(i.h3,{id:"jemalloc",children:["Jemalloc",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#jemalloc",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:[e.jsx(i.a,{href:"https://jemalloc.net/",children:"Jemalloc"})," is a general-purpose allocator that is used ",e.jsx(i.a,{href:"https://engineering.fb.com/2011/01/03/core-data/scalable-memory-allocation-using-jemalloc/",children:"across the industry in production"}),`, well known for its performance benefits, predictability, and profiling capabilities.
We've seen significant performance benefits in reth when using jemalloc, but will be primarily focusing on its profiling capabilities.
Jemalloc also provides tools for analyzing and visualizing its allocation profiles it generates, notably `,e.jsx(i.code,{children:"jeprof"}),"."]}),`
`,e.jsxs(i.h4,{id:"enabling-jemalloc-in-reth",children:["Enabling jemalloc in reth",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#enabling-jemalloc-in-reth",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["Reth includes a ",e.jsx(i.code,{children:"jemalloc"})," feature to explicitly use jemalloc instead of the system allocator:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"cargo build --features jemalloc"})})})})}),`
`,e.jsxs(i.p,{children:["While the ",e.jsx(i.code,{children:"jemalloc"})," feature does enable jemalloc, reth has an additional feature, ",e.jsx(i.code,{children:"profiling"}),", that must be used to enable heap profiling. This feature implicitly enables the ",e.jsx(i.code,{children:"jemalloc"}),`
feature as well:`]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"cargo build --features jemalloc-prof"})})})})}),`
`,e.jsxs(i.p,{children:["When performing a longer-running or performance-sensitive task with reth, such as a sync test or load benchmark, it's usually recommended to use the ",e.jsx(i.code,{children:"maxperf"})," profile. However, the ",e.jsx(i.code,{children:"maxperf"}),`
profile does not enable debug symbols, which are required for tools like `,e.jsx(i.code,{children:"perf"})," and ",e.jsx(i.code,{children:"jemalloc"})," to produce results that a human can interpret. Reth includes a performance profile with debug symbols called ",e.jsx(i.code,{children:"profiling"}),". To compile reth with debug symbols, jemalloc, profiling, and a performance profile:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsxs(i.code,{children:[e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"cargo build --features jemalloc-prof --profile profiling"})}),`
`,e.jsx(i.span,{className:"line","data-empty-line":!0,children:" "}),`
`,e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#005CC5",fontWeight:"bold","--shiki-dark":"#6CB6FF","--shiki-dark-font-weight":"bold"},children:"# May improve performance even more"})}),`
`,e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:'RUSTFLAGS="-C target-cpu=native" cargo build --features jemalloc-prof --profile profiling'})})]})})}),`
`,e.jsxs(i.h3,{id:"monitoring-memory-usage",children:["Monitoring memory usage",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#monitoring-memory-usage",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["Reth's dashboard has a few metrics that are important when monitoring memory usage. The ",e.jsx(i.strong,{children:"Jemalloc memory"})," graph shows reth's memory usage. The ",e.jsx(i.em,{children:"allocated"})," label shows the memory used by the reth process which cannot be reclaimed unless reth frees that memory. This metric exceeding the available system memory would cause reth to be killed by the OOM killer."]}),`
`,e.jsx("img",{width:"749",alt:"Jemalloc memory",src:"https://github.com/paradigmxyz/reth/assets/6798349/2653c5a2-bd7c-46a6-a593-23809389628e"}),`
`,e.jsx(i.p,{children:"Some of reth's internal components also have metrics for the memory usage of certain data structures, usually data structures that are likely to contain many elements or may consume a lot of memory at peak load."}),`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"The bodies downloader buffer"}),":"]}),`
`,e.jsx("img",{width:"749",alt:"The bodies downloader buffer graph",src:"https://github.com/paradigmxyz/reth/assets/6798349/75383724-24ae-4f4f-98a9-72d01731a5f9"}),`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"The blockchain tree block buffer"}),":"]}),`
`,e.jsx("img",{width:"749",alt:"The blockchain tree block buffer graph",src:"https://github.com/paradigmxyz/reth/assets/6798349/7162c6d4-ed18-48c1-a327-50a245dabc95"}),`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"The transaction pool subpools"}),":"]}),`
`,e.jsx("img",{width:"749",alt:"The transaction pool subpool size graph",src:"https://github.com/paradigmxyz/reth/assets/6798349/c5066fd6-7ff7-4e62-9226-89327c7a802c"}),`
`,e.jsx(i.p,{children:`One of these metrics growing beyond, 2GB for example, is likely a bug and could lead to an OOM on a low memory machine. It isn't likely for that to happen frequently, so in the best case these metrics can be used to
rule out these components from having a leak, if an OOM is occurring.`}),`
`,e.jsxs(i.h3,{id:"limiting-process-memory",children:["Limiting process memory",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#limiting-process-memory",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:[`Memory leaks that cause OOMs can be difficult to trigger sometimes, and highly depend on the testing hardware. A testing machine with 128GB of RAM is not going to encounter OOMs caused by
memory spikes or leaks as often as a machine with only 8GB of RAM. Development machines are powerful for a reason, so artificially limiting memory usage is often the best way to replicate a
user's hardware. This can help developers debug issues that only occur on devices with limited hardware. `,e.jsx(i.code,{children:"cgroups"}),` is a tool that allows developers to limit the memory usage of a process,
making it extremely useful to developers in understanding how their application performs in low-memory environments.`]}),`
`,e.jsxs(i.p,{children:["See the ",e.jsx(i.a,{href:"https://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup.git/tree/Documentation/admin-guide/cgroup-v2.rst",children:"canonical documentation for cgroups"})," for more information."]}),`
`,e.jsxs(i.h3,{id:"how-to-use-cgroups-to-limit-process-memory",children:["How to use cgroups to limit process memory",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#how-to-use-cgroups-to-limit-process-memory",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx(i.p,{children:`In order to use cgroups to limit process memory, sometimes it must be explicitly enabled as a kernel parameter. For example, the following line is sometimes necessary to enable cgroup memory limits on
Ubuntu machines that use GRUB:`}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:'GRUB_CMDLINE_LINUX_DEFAULT="cgroup_enable=memory"'})})})})}),`
`,e.jsx(i.p,{children:"Then, create a named cgroup:"}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"sudo cgcreate -t $USER:$USER -a $USER:$USER -g memory:rethMemory"})})})})}),`
`,e.jsxs(i.p,{children:["The memory limit for the named cgroup can be set in ",e.jsx(i.code,{children:"sys/fs/cgroup/memory"}),". This for example sets an 8 gigabyte memory limit:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"echo 8G > /sys/fs/cgroup/memory/rethMemory/memory.limit_in_bytes"})})})})}),`
`,e.jsxs(i.p,{children:[`If the intention of setting up the cgroup is to strictly limit memory and simulate OOMs, a high amount of swap may prevent those OOMs from happening.
To check swap, use `,e.jsx(i.code,{children:"free -m"}),":"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsxs(i.code,{children:[e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"ubuntu@bench-box:~/reth$ free -m"})}),`
`,e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"              total        used        free      shared  buff/cache   available"})}),`
`,e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"Mem:         257668       10695      218760          12       28213      244761"})}),`
`,e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"Swap:          8191         159        8032"})})]})})}),`
`,e.jsx(i.p,{children:"If this is a problem, it may be worth either adjusting the system swappiness or disabling swap overall."}),`
`,e.jsxs(i.p,{children:["Finally, ",e.jsx(i.code,{children:"cgexec"})," can be used to run reth under the cgroup:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"cgexec -g memory:rethMemory reth node"})})})})}),`
`,e.jsxs(i.h3,{id:"understanding-allocation-with-jeprof",children:["Understanding allocation with jeprof",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#understanding-allocation-with-jeprof",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["When reth is built with the ",e.jsx(i.code,{children:"jemalloc-prof"})," feature and debug symbols, the profiling still needs to be configured and enabled at runtime. This is done with the ",e.jsx(i.code,{children:"_RJEM_MALLOC_CONF"}),` environment variable. Take the following
command to launch reth with jemalloc profiling enabled:`]}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsx(i.code,{children:e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"_RJEM_MALLOC_CONF=prof:true,lg_prof_interval:32,lg_prof_sample:19 reth node"})})})})}),`
`,e.jsx(i.p,{children:"If reth is not built properly, you will see this when you try to run reth:"}),`
`,e.jsx(e.Fragment,{children:e.jsx(i.pre,{className:"shiki shiki-themes github-light github-dark-dimmed",style:{backgroundColor:"#fff","--shiki-dark-bg":"#22272e",color:"#24292e","--shiki-dark":"#adbac7"},tabIndex:"0",children:e.jsxs(i.code,{children:[e.jsx(i.span,{className:"line",children:e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"~/p/reth (dan/managing-memory)> _RJEM_MALLOC_CONF=prof:true,lg_prof_interval:32,lg_prof_sample:19 reth node"})}),`
`,e.jsxs(i.span,{className:"line",children:[e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"<"}),e.jsx(i.span,{style:{color:"#22863A","--shiki-dark":"#8DDB8C"},children:"jemalloc"}),e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:">: Invalid conf pair: prof:true"})]}),`
`,e.jsxs(i.span,{className:"line",children:[e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"<"}),e.jsx(i.span,{style:{color:"#22863A","--shiki-dark":"#8DDB8C"},children:"jemalloc"}),e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:">: Invalid conf pair: lg_prof_interval:32"})]}),`
`,e.jsxs(i.span,{className:"line",children:[e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:"<"}),e.jsx(i.span,{style:{color:"#22863A","--shiki-dark":"#8DDB8C"},children:"jemalloc"}),e.jsx(i.span,{style:{color:"#24292E","--shiki-dark":"#ADBAC7"},children:">: Invalid conf pair: lg_prof_sample:19"})]})]})})}),`
`,e.jsxs(i.p,{children:["If this happens, jemalloc likely needs to be rebuilt with the ",e.jsx(i.code,{children:"jemalloc-prof"})," feature enabled."]}),`
`,e.jsxs(i.p,{children:["If everything is working, this will output ",e.jsx(i.code,{children:"jeprof.*.heap"}),` files while reth is running.
`,e.jsx(i.a,{href:"https://jemalloc.net/jemalloc.3.html#opt.abort",children:"The jemalloc website"})," has a helpful overview of the options available, for example ",e.jsx(i.code,{children:"lg_prof_interval"}),", ",e.jsx(i.code,{children:"lg_prof_sample"}),", ",e.jsx(i.code,{children:"prof_leak"}),", and ",e.jsx(i.code,{children:"prof_final"}),"."]}),`
`,e.jsxs(i.p,{children:["Now that we have the heap snapshots, we can analyze them using ",e.jsx(i.code,{children:"jeprof"}),". An example of jeprof usage and output can be seen on the jemalloc github repository: ",e.jsx(i.a,{href:"https://github.com/jemalloc/jemalloc/wiki/Use-Case:-Leak-Checking",children:"https://github.com/jemalloc/jemalloc/wiki/Use-Case:-Leak-Checking"})]})]})}function o(s={}){const{wrapper:i}={...n(),...s.components};return i?e.jsx(i,{...s,children:e.jsx(r,{...s})}):r(s)}export{o as default,l as frontmatter};
